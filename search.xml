<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[前端学习笔记]]></title>
      <url>/2018/01/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><ol>
<li><h1 id="HTML-超文本标记语言——HyperText-Markup-Language"><a href="#HTML-超文本标记语言——HyperText-Markup-Language" class="headerlink" title="HTML(超文本标记语言——HyperText Markup Language)"></a>HTML(超文本标记语言——HyperText Markup Language)</h1>“超文本”是指在单个网站内或网站之间将网页彼此连接的链接。链接是网络的基础。只要将内容上传到互联网，并将其与他人创建的页面相链接，你就成为了万维网的积极参与者。<br>HTML使用“标记”来注明文本、图片和其他内容，以便于在Web浏览器中显示。HTML标记包含一些特殊“元素”如<br> <code>&lt;html&gt;,&lt;head&gt;，&lt;title&gt;，&lt;body&gt;，&lt;header&gt;，&lt;footer&gt;，&lt;article&gt;，&lt;section&gt;，&lt;p&gt;，&lt;nav&gt;,&lt;div&gt;，&lt;span&gt;，&lt;img&gt;</code>等等<br> <strong>元数据</strong>就是描述数据的数据，而HTML有一个“官方的”方式来为一个文档添加元数据，——  <meta> 元素. 当然，其他在这篇文章中提到的东西也可以被当作元数据。 有很多不同种类的 <meta> 元素可以被包含进你的页面的<head>元素, 但是现在我们还不会尝试去解释它们, 这只会引起混乱。 我们会解释一些你常会看到的东西，我们只会给你一个想法。<h3 id="块级元素和内联元素"><a href="#块级元素和内联元素" class="headerlink" title="块级元素和内联元素"></a>块级元素和内联元素</h3></head></li>
</ol>
<ul>
<li>块级元素在页面中以块的形式展现 —— 相对与其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。块级元素通常用于展示页面上结构化的内容，类似于段落、列表、导航菜单、页脚等等。一个以block形式展现的块级元素不会被嵌套进内联元素中，但可以嵌套在其它块级元素中。</li>
<li>内联元素通常出现在块级元素中并被一些其它文本所包围，而不是一整个段落或者一组内容。内联元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素<code>&lt;a&gt;</code>或者强调元素<code>&lt;em&gt;</code>和 <code>&lt;strong&gt;</code>。</li>
<li><code>&lt;!DOCTYPE html&gt;:</code> 声明文档类型. 很久以前，早期的HTML(大约1991/2年)，文档类型声明类似于链接，规定了HTML页面必须遵从的良好规则，能自动检测错误和其他有用的东西。使用如下：<br><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</code><br><code>&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code><br>然而现在没有人再这样写，需要保证每一个东西都正常工作已成为历史。你只需要知道&lt;!DOCTYPE html&gt;是最短的有效的文档声明。<br><code>&lt;html&gt;&lt;/html&gt;: &lt;html&gt;</code>元素。这个元素包裹了整个完整的页面，是一个根元素。<br><code>&lt;head&gt;&lt;/head&gt;: &lt;head&gt;</code>元素. 这个元素是一个容器，它包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等。以后的章节能学到更多关于<code>&lt;head&gt;</code>元素的内容。<br><code>&lt;meta charset=&quot;utf-8&quot;&gt;:</code> 这个元素设置文档使用utf-8字符集编码，utf-8字符集包含了人类大部分的文字。基本上他能识别你放上去的所有文本内容。毫无疑问要使用它，并且它能在以后避免很多其他问题。<br><code>&lt;title&gt;&lt;/title&gt;:</code>设置页面标题，出现在浏览器标签上，当你标记/收藏页面时它可用来描述页面。<br><code>&lt;body&gt;&lt;/body&gt;: &lt;body&gt;</code>元素。 包含了你访问页面时所有显示在页面上的内容，文本，图片，音频，游戏等等。<h2 id="统一资源定位器-URL-与路径-path-快速入门"><a href="#统一资源定位器-URL-与路径-path-快速入门" class="headerlink" title="统一资源定位器(URL)与路径(path)快速入门"></a>统一资源定位器(URL)与路径(path)快速入门</h2></li>
</ul>
<ol>
<li><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1></li>
</ol>
<ul>
<li>CSS是一种用来设计网页样式的语言（比如，用它改变字体、颜色或页面布局等）</li>
<li>DOM是一种树形结构. 标记语言中的每个元素,属性,文本片段都变为一个 DOM 节点。这些节点由它们与其它 DOM 节点的关系来定义。有的元素是某些子节点的父节点，且这些子节点有兄弟（节点）。由于 DOM 是 CSS 与文档内容的相遇之处，理解 DOM 有助于设计，调试和维护你的 CSS 文件。<h2 id="不同种类的CSS选择器"><a href="#不同种类的CSS选择器" class="headerlink" title="不同种类的CSS选择器:"></a>不同种类的CSS选择器:</h2>选择器可以被分为以下类别：</li>
</ul>
<ol>
<li>简单选择器（Simple selectors）：通过元素(类型)选择器、class 或 id 匹配一个或多个元素。</li>
<li>属性选择器（Attribute selectors）：通过 属性 / 属性值 匹配一个或多个元素。</li>
<li>伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。</li>
<li>伪元素（Pseudo-elements）:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 </li>
<li>组合器（Combinators）：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在headings后面的段落。<br>6.多用选择器（Multiple selectors）：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个CSS规则下面， 以将一组声明应用于由这些选择器选择的所有元素。</li>
<li><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1></li>
</ol>
<ul>
<li>ECMAScript+BOM(Browser Object Model)+DOM(Document Object Model)组成JavaScript<br>  var(定义松散变量),var 操作符定义的变量将成为定义该变量的作用域中的局部变量<br>  如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁</li>
</ul>
<h1 id="编程就是学习规则，不难，学会了规则，就可以写出高效、可维护的代码"><a href="#编程就是学习规则，不难，学会了规则，就可以写出高效、可维护的代码" class="headerlink" title="编程就是学习规则，不难，学会了规则，就可以写出高效、可维护的代码"></a>编程就是学习规则，不难，学会了规则，就可以写出高效、可维护的代码</h1>]]></content>
      
        <categories>
            
            <category> 前端学习笔记 </category>
            
            <category> html </category>
            
            <category> css </category>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端学习笔记 </tag>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[两大偶像]]></title>
      <url>/2018/01/24/%E4%B8%A4%E5%A4%A7%E5%81%B6%E5%83%8F/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><ul>
<li><strong>马云</strong>是中国电子商务的创新者和开拓者，给中国带来了新的经济发展模式，带动了网上购物上下游的产业，是互联网时代成功的商人，阿里巴巴很多开源项目都很有技术功底。</li>
<li><strong>Mark Elliot Zuckerberg</strong>(马克.扎克伯格)创办的<strong>facebook</strong>连接全世界，马克是一个崇尚技术改变世界的人，不追求功利，很欣赏他的心态。</li>
<li>当然，一个最大的共同点，他们都很有钱，特别是马克，年纪轻轻，常驻福布斯前十呀，还淡泊名利，啧啧。</li>
<li><pre>如果有一天我变得很有钱
我的第一选择不是去环游世界
躺在世界上最大最软的沙发里
吃了就睡醒了再吃先过一年
如果有一天我变得很有钱
我就可以把所有人都留在我身边
每天快快乐乐吃吃喝喝聊聊天
不用担心关于明天和离别
变有钱 我变有钱
多少人没日没夜地浪费时间
变有钱 我变有钱
然后故作谦虚说金钱不是一切
如果有一天我变得很有钱
我会买下所有难得一见的笑脸
让所有可怜的孩子不再胆怯
所有邪恶的人不再掌握话语权
如果有一天我变得很有钱
我会想尽一切办法倒流时间
不是为了人类理想做贡献
只是想和她说一句我很抱歉
变有钱 我变有钱
多少人没日没夜地浪费时间
变有钱 我变有钱
然后故作谦虚的说金钱不是一切
我变有钱
所有烦恼都被留在天边
变有钱 我变有钱
然后发自内心地说金钱它不是一切</pre></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 偶像 </category>
            
            <category> 创业 </category>
            
            <category> 企业 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 偶像 </tag>
            
            <tag> 创业 </tag>
            
            <tag> 企业 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[es6+node.js+mysql]]></title>
      <url>/2018/01/23/es6-node-js-mysql/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="es6-react-mysql-jade-node-js"><a href="#es6-react-mysql-jade-node-js" class="headerlink" title="es6+react+mysql+jade+node.js"></a>es6+react+mysql+jade+node.js</h2>]]></content>
      
        <categories>
            
            <category> node.js </category>
            
            <category> react </category>
            
            <category> es6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node.js </tag>
            
            <tag> react </tag>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[未来与科技的思考]]></title>
      <url>/2018/01/05/%E6%9C%AA%E6%9D%A5k%E4%B8%8E%E7%A7%91%E6%8A%80%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>#关于未来与科技的思考</p>
<p>##未来是什么</p>
<p><div align="left">每一次的技术革命都是造成</div><br>未来三十年，是个好时代，是个动荡的时代<br>《红旗法案》</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[AI Learning]]></title>
      <url>/2017/12/21/AI-Learning/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
      
        <categories>
            
            <category> AI </category>
            
            <category> Future </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript notes]]></title>
      <url>/2017/09/26/JavaScript/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div><br>## JavaScript简介<br><em> DOM+ECMAScript+BOM=JavaScript;<br>    语法，类型，语句，关键字，保留字，操作符，对象。<br>(Document Object Model) (Browser Object Model)<br>提供访问和操作网页内容的方法和接口 提供与浏览器交互的方法和接口<br>BOM对象 : window document location navigator screen<br><script async="async" defer="defer" language="javascript" type="text/javascript"><br>    //转义字符<br>alert(“&lt;\/script&gt;”);<br>//async 立即下载脚本 一定在页面load之前 可能在DOMContentLoaded之前之后<br>// defer 延迟到文档完全被解析和显示后执行<br>alert(“\</script>“);<br><br>（1）<br>1.初始化/销毁对象  var object=null;<br>typeof null=object;(空对象指针);<br>2:var a=new Object();<br>a.constructor=function Object(){}<br>a.hasOwnProperty(“name”) 对象自身的属性，而不包括从原型对象继承的属性<br>3.isPrototypeOf(objectname)检查传入的对象是否是原型<br>（2）<br>面向对象的程序设计<br>（3）break和continue语句<br>break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，<br>强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶<br>部继续执行。请看下面的例子：<br>var num = 0;<br>for (var i=1; i &lt; 10; i++) {<br> if (i % 5 == 0) {<br> break;<br> }<br> num++;<br>}<br>alert(num); //4<br>这个例子中的 for 循环会将变量 i 由 1 递增至 10。在循环体内，有一个 if 语句检查 i 的值是否<br>可以被 5 整除（使用求模操作符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开<br>始，用于记录循环执行的次数。在执行 break 语句之后，要执行的下一行代码是 alert()函数，结果<br>显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在<br>num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果：<br>var num = 0;<br>for (var i=1; i &lt; 10; i++) {<br> if (i % 5 == 0) {<br> continue;<br> }  num++;<br>}<br>alert(num); //8<br>例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前<br>退出，但接下来执行的是下一次循环，即 i 的值等于 6 的循环。于是，循环又继续执行，直到 i 等于<br>10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。<br>break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合<br>使用的情况多发生在循环嵌套的情况下，如下面的例子所示：<br>var num = 0;<br>outermost:<br>for (var i=0; i &lt; 10; i++) {<br> for (var j=0; j &lt; 10; j++) {<br> if (i == 5 &amp;&amp; j == 5) {<br> break outermost;<br> }<br> num++;<br> }<br>}<br>alert(num); //55<br>在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++<br>语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中<br>的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内<br>部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，<br>当变量 i 和 j 都等于 5 时，num 的值正好是 55。同样，continue 语句也可以像这样与 label 语句联<br>用，如下面的例子所示：<br>var num = 0;<br>outermost:<br>for (var i=0; i &lt; 10; i++) {<br> for (var j=0; j &lt; 10; j++) {<br> if (i == 5 &amp;&amp; j == 5) {<br> continue outermost;<br> }<br> num++;<br> }<br>}<br>alert(num); //95<br>在这种情况下，continue 语句会强制继续执行循环——退出内部循环，执行外部循环。当 j 是 5<br>时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。<br>虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试<br>带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。<br>function doAdd() {<br> if(arguments.length == 1) {<br> alert(arguments[0] + 10);<br> } else if (arguments.length == 2) {<br> alert(arguments[0] + arguments[1]);<br> }<br>}<br>doAdd(10); //20<br>doAdd(30, 20); //50<br>函数 doAdd()会在只有一个参数的情况下给该参数加上 10；如果是两个参数，则将那个参数简单<br>相加并返回结果。因此，doAdd(10)会返回 20，而 doAdd(30,20)则返回 50。虽然这个特性算不上完<br>美的重载，但也足够弥补 ECMAScript 的这一缺憾了。<br>另一个与参数相关的重要方面，就是 arguments 对象可以与命名参数一起使用，如下面的例子所示：<br>function doAdd(num1, num2) {<br> if(arguments.length == 1) {<br> alert(num1 + 10);<br> } else if (arguments.length == 2) {<br> alert(arguments[0] + num2);<br> }<br>}<br>通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载<br>在重写后的这个 doAdd()函数中，两个命名参数都与 arguments 对象一起使用。由于 num1 的值<br>与 arguments[0]的值相同，因此它们可以互换使用（当然，num2 和 arguments[1]也是如此）。<br>关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。<br>例如：<br>function doAdd(num1, num2) {<br> arguments[1] = 10;<br> alert(arguments[0] + num2);<br>}<br>每次执行这个 doAdd()函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments<br>对象中的值会自动反映到对应的命名参数，所以修改 arguments[1]，也就修改了 num2，结果它们的<br>值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但<br>它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 arguments[1]设置的值不会反应到<br>命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，（eg:<br>function doAdd(num1, num2) {<br> arguments[1] = 10;<br> alert(arguments[0] + num2);<br>}<br>doAdd(34)<br>//undefined<br>因为实参长度不为2，arguments长度由实参决定。<br>）不是由定义函数时的命名<br>参数的个数决定的。<br>关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了<br>变量但又没有初始化一样。例如，如果只给 doAdd()函数传递了一个参数，则 num2 中就会保存<br>undefined 值。<br>严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无<br>效。也就是说，即使把 arguments[1]设置为 10，num2 的值仍然还是 undefined。其次，重写<br>arguments 的值会导致语法错误（代码将不会执行）。<br>ECMAScript语法(类c):<br>1.ECMAScript中一切（变量，函数名，操作符）都区分大小写。test 和 Test是两个变量名。<br>2. 标识符（变量，函数，属性的名字或者函数的参数）第一个字符必须是字母，下划线( _ )，美元符号（$）<br>其他字符可以是 数字，字母，下划线，$ 可以包含扩展的ASCII或Unicode字母  采用驼峰大小写格式<br> eg: firstSecond,myCar,doSomethingImportant<br>不能把关键字保留字 true,false,null用作标识符<br>3.注释<br>//单行<br>/</em><br><em>块级
</em>注释<br>*/（企业级应用注释格式）<br>4.严格模式<br>“use strict”(编译指示 pragma)为JavaScript定义了一种不同的解析与执行模型<br>5.ECMAScript变量是松散类型（可以用来保存任何类型的数据）的，每个变量仅仅是一个用于保存值的占位符。<br>eg:var message;(message==undefined)<br>eg:var name=”lily”;(初始化)name=100;(改变变量值的同时改变值的类型)<br>使用var操作符定义的变量将成为该变量作用域的局部变量 （在函数中使用var定义一个变量，那么变量在函数退出后被销毁）<br>eg:function test(){<br>var message=”HI”;<br>return;<br>}<br>test();<br>alert(message);//undefined<br>省略var可以定义全局变量<br>eg:function test(){<br>//“use strict” //严格模式下报错 相应变量不会马上就有定义，不易维护//不一定，待考证<br> message=”HI”;<br>return;<br>}<br>test();<br>alert(message);//HI<br>一条语句定义多个变量 var message=”hi”,found=false,age=100,testArr=[“set”,100,”HI”];<br>## 6.数据类型<br>5种简单（基本）数据类型:<br><strong>Undefined</strong>:<br>(var message==var message=undefined)<br>var message;undefined==message;typeof age==”undefined”//true<br><strong>Null</strong>:<br>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null(空的对象引用)<br>if (car != null){<br>// 对 car 对象执行某些操作<br>}<br>var newObject=null;<br>null == undefined;<br><strong>Boolean</strong>: true false<br>可以对任何数据类型的值调用 Boolean() 函数，而且总会返回一个 Boolean 值<br>要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()<br>eg:var message = “Hello world!”;<br>var messageAsBoolean = Boolean(message);<br><strong>Number</strong>:<br>var intNum = 55; // 整数<br>var octalNum1 = 070; // 八进制的 56<br>var octalNum2 = 079; // 无效的八进制数值——解析为 79<br>var octalNum3 = 08; // 无效的八进制数值——解析为 8<br>var hexNum1 = 0xA; // 十六进制的 10<br>var hexNum2 = 0x1f; // 十六进制的 31<br>0/0!=NaN//NaN<br>任何涉及 NaN 的操作（例如 NaN /10）都会返回 NaN<br> NaN 与任何值都不相等，包括 NaN 本身<br>isNaN();<br>alert(isNaN(NaN)); //true<br>alert(isNaN(10)); //false（10 是一个数值）<br>alert(isNaN(“10”)); //false（可以被转换成数值 10）<br>alert(isNaN(“blue”)); //true（不能转换成数值）<br>alert(isNaN(true)); //false（可以被转换成数值 1）<br>在基于对象调用 isNaN()<br>函数时，会首先调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转<br>换为数值。如果不能，则基于这个返回值再调用 toString() 方法，再测试返回值。<br>而这个过程也是 ECMAScript中内置函数和操作符的一般执行流程<br>String:<br>ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变<br>某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，<br>例如：<br>var lang = “Java”;<br>lang = lang + “Script”;<br>以上示例中的变量 lang 开始时包含字符串 “Java” 。而第二行代码把 lang 的值重新定义为 “Java”<br>与 “Script” 的组合，即 “JavaScript” 。实现这个操作的过程如下：首先创建一个能容纳 10 个字符的<br>新字符串，然后在这个字符串中填充 “Java” 和 “Script” ，最后一步是销毁原来的字符串 “Java” 和字<br>符串 “Script” ，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的<br>图灵社区会员 StinkBC(StinkBC@gmail.com) 专享 尊重版权<br>34 第 3章 基本概念<br>浏览器（例如版本低于 1.0 的 Firefox、IE6 等）中拼接字符串时速度很慢的原因所在。但这些浏览器后<br>来的版本已经解决了这个低效率问题。<br>var num = 10;<br>alert(num.toString()); // “10”<br>alert(num.toString(2)); // “1010”<br>alert(num.toString(8)); // “12”<br>alert(num.toString(10)); // “10”<br>alert(num.toString(16)); // “a”<br>1种复杂数据类型:<br>Object-由一组无序的键值对组成；<br>    ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建<br>的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定<br>义对象，如下所示：<br>var o = new Object();<br>即在 ECMAScript 中，<br>（就像 Java 中的 java.lang.Object 对象一样） Object 类型是所有它的实例的基础。换句话说，<br>Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。<br>Object 的每个实例都具有下列属性和方法。<br> constructor ：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）<br>就是 Object() 。<br> hasOwnProperty(propertyName) ：用于检查给定的属性在当前对象实例中（而不是在实例<br>的原型中也不是在构造函数中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例<br>如： o.hasOwnProperty(“name”) ）。<br> isPrototypeOf(object) ：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原<br>型）。<br> propertyIsEnumerable(propertyName) ：用于检查给定的属性是否能够使用 for-in 语句<br>（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符<br>串形式指定。<br> toLocaleString() ：返回对象的字符串表示，该字符串与执行环境的地区对应。<br> toString() ：返回对象的字符串表示。<br> valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值<br>相同。<br>function People(name,sex,age){<br>    this.name=name;<br>this.sex=sex;<br>this.age=age;<br>};<br>var lily=new People(“lily”,”female”,20);<br>从技术角度讲，ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。<br>浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是<br>由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也<br>可能不会继承 Object<br>ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、<br>关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字<br>符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()<br>和（或） toString() 方法，以便取得可以操作的值。<br>检测数据类型 typeof:<br>“undefined”值未定义；<br>“boolean”值是布尔值；<br>“string”值是字符串；<br>“number”值是数值；<br>“object”值是对象；<br>“function”值是函数（是对象，与对象又区分）<br>typeof null=&gt;”object”  null表示空对象指针<br>7.数值转换<br>有 3 个函数可以把非数值转换为数值： Number()<br>Number() 函数的转换规则如下。<br>  如果是 Boolean 值， true 和 false 将分别被转换为 1 和 0。<br>  如果是数字值，只是简单的传入和返回。<br>  如果是 null 值，返回 0。<br>  如果是 undefined ，返回 NaN 。<br>  如果是字符串，遵循下列规则：<br>  如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即 “1”<br>会变成 1， “123” 会变成 123，而 “011” 会变成 11（注意：前导的零被忽略了）；<br>  如果字符串中包含有效的浮点格式，如 “1.1” ，则将其转换为对应的浮点数值（同样，也会忽<br>略前导零）；<br>  如果字符串中包含有效的十六进制格式，例如 “0xf” ，则将其转换为相同大小的十进制整<br>数值；<br>  如果字符串是空的（不包含任何字符），则将其转换为 0；<br>  如果字符串中包含除上述格式之外的字符，则将其转换为 NaN 。<br>  如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换<br>的结果是 NaN ，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符<br>在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String() ，这个<br>函数能够将任何类型的值转换为字符串。 String() 函数遵循下列转换规则：<br>  如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果；<br>  如果值是 null ，则返回 “null” ；<br>  如果值是 undefined ，则返回 “undefined” 。<br>下面再看几个例子：<br>var value1 = 10;<br>var value2 = true;<br>var value3 = null;<br>var value4;<br>alert(String(value1)); // “10”<br>alert(String(value2)); // “true”<br>alert(String(value3)); // “null”<br>alert(String(value4)); // “undefined”<br>串值。<br>var num1 = Number(“Hello world!”); //NaN<br>var num2 = Number(“”); //0<br>var num3 = Number(“000011”); //11<br>var num4 = Number(true); //1<br>一元加操作符（+）的操作与 Number() 函数相同<br> 、 parseInt()<br> parseInt() 函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字<br>符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， parseInt()<br>就会返回 NaN ；也就是说，用 parseInt() 转换空字符串会返回 NaN （ Number() 对空字符返回 0）。如<br>果第一个字符是数字字符， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了<br>一个非数字字符。<br>var num = parseInt(“0xAF”, 16); //175<br>var num1 = parseInt(“10”, 2); //2 （按二进制解析）<br>var num2 = parseInt(“10”, 8); //8 （按八进制解析）<br>var num3 = parseInt(“10”, 10); //10 （按十进制解析）<br>var num4 = parseInt(“10”, 16); //16 （按十六进制解析）<br>parseFloat()：<br>与 parseInt() 函数类似， parseFloat() 也是从第一个字符（位置 0）开始解析每个字符。而且<br>也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第<br>一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，<br>“22.34.5” 将会被转换为 22.34。<br>除了第一个小数点有效之外， parseFloat() 与 parseInt() 的第二个区别在于它始终都会忽略前导<br>的零。 parseFloat() 可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格<br>式的字符串则始终会被转换成 0。由于 parseFloat() 只解析十进制值，因此它没有用第二个参数指定基<br>数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后<br>都是零）， parseFloat() 会返回整数<br>var num1 = parseFloat(“1234blue”); //1234 （整数）<br>var num2 = parseFloat(“0xA”); //0<br>var num3 = parseFloat(“22.5”); //22.5<br>var num4 = parseFloat(“22.34.5”); //22.34<br>var num5 = parseFloat(“0908.5”); //908.5<br>var num6 = parseFloat(“3.125e7”); //31250000<br>8.运算符<br>-100-1==~100 按位非<br>9.逗号运算符<br>使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：<br>var num1=1, num2=2, num3=3;<br>逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号<br>操作符总会返回表达式中的最后一项，如下面的例子所示：<br>var num = (5, 1, 4, 8, 0); // num 的值为 0<br>由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个<br>例子可以帮我们理解逗号的这种行为。<br>（2）变量、作用域和内存<br>基本类型和引用类型的值<br>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是<br>简单的数据段，而引用类型值指那些可能由多个值构成的对象。<br>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第 3 章讨论了 5 种<br>基本数据类型： Undefined 、 Null 、 Boolean 、 Number 和 String 。这 5 种基本数据类型是按值访问<br>的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，<br>也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。<br>为此，引用类型的值是按引用访问的<br>当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际<br>的对象<br></div>

]]></content>
      
        <categories>
            
            <category> 学习 </category>
            
            <category> javascript </category>
            
            <category> 笔记 </category>
            
            <category> Professional JavaScript for Web Developers </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> notes </tag>
            
            <tag> Professional JavaScript for Web Developers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github pages+hexo搭建博客]]></title>
      <url>/2017/09/20/github-pages-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Web 前端爱好者。写博客的好处，不是为了写而写，而是一个记录思想的过程。不要考虑它能带给你什么，而是你自己从中收获了什么。<br>最近刚好有空，于是就参照网上的各种教程，搭建了一个博客。现在把 Hexo + GitHub Pages 搭建博客的完整过程记录下来：</p>
<p><strong>大概流程</strong>：<br><br>1. 搭建 Node.js 环境<br><br>2. 搭建 Git 环境<br><br>3. GitHub 注册和配置<br><br>4. 安装配置 Hexo<br><br>5. 关联 Hexo 与 GitHub Pages<br><br>6. GitHub Pages 地址解析到个人域名<br><br>7. Hexo 的常用操作<br><br>8. 结束语</p><br><h2 id="nodejs"><a class="headeranchor-link" name="user-content-nodejs" href="#nodejs"></a>搭建 Node.js 环境</h2><br><blockquote><br><p>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的</p>

<p></p></blockquote><p></p>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。</p><br><p>在 Node.js 官网：<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a> 下载安装包 <code>v8.9.4 LTS</code></p><br><p>保持默认设置即可，一路Next，安装很快就结束了。</p><br><em> 然后打开命令提示符，输入 <code>node -v</code>、<code>npm -v</code>，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！<p></p>
</em> npm 是node.js的工具包，里面包含了很多优秀程序员开发的工具和库。<br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-28/25738843.jpg" alt=""></p><br><h2 id="git"><a class="headeranchor-link" name="user-content-git" href="#git"></a>搭建 Git 环境</h2><br><blockquote><br><p>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。</p>

<p></p></blockquote><p></p>
<p>Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><br><p>在 Git 官网：<a href="https://git-scm.com/" target="_blank" rel="external">https://git-scm.com/</a> 下载安装包 <code>Git-2.13.0-64-bit.exe</code></p><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-28/62582265.jpg" alt=""></p><br><p>桌面右键，打开 <code>Git Bush Here</code>，输入 <code>git –version</code>，出现版本号则说明 Git 环境配置成功，第二步完成！！！</p><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-28/13485948.jpg" alt=""></p><br><h2 id="github"><a class="headeranchor-link" name="user-content-github" href="#github"></a>GitHub 注册和配置</h2><br><p>GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。</p><br><p>Github注册：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p><br><p><iframe id="iframe_0.5607328742099007" src="data:text/html;charset=utf8,%3Cstyle%3Ebody%7Bmargin:0;padding:0%7D%3C/style%3E%3Cimg%20id=%22img%22%20src=%22http://img.mukewang.com/57eea87a0001c62213450582.png?_=6927340%22%20style=%22border:none;max-width:701px%22%3E%3Cscript%3Ewindow.onload%20=%20function%20()%20%7Bvar%20img%20=%20document.getElementById('img');%20window.parent.postMessage(%7BiframeId:'iframe_0.5607328742099007',width:img.width,height:img.height%7D,%20'http://www.cnblogs.com');%7D%3C/script%3E" style="border: none; width: 701px; height: 303px;" frameborder="0" scrolling="no"></iframe></p><br><p>创建仓库：Repository name 使用自己的用户名，仓库名规则：</p><br><p><strong>注意</strong>：<code>yourname</code> 必须是你自己的用户名。</p><br><pre><code>yourname/yourname.github.io<br></code></pre><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-28/42622869.jpg" alt=""></p><br><p>访问 yourname.github.io，如果可以正常访问，那么 Github 的配置已经结束了。</p><br><p>到此搭建 Hexo 博客的相关环境配置已经完成，下面开始讲解 Hexo 的相关操作</p><br><h2 id="hexo"><a class="headeranchor-link" name="user-content-hexo" href="#hexo"></a>安装配置 Hexo</h2><br><p>Hexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><br><p>强烈建议你花20分钟区读一读 Hexo 的官方文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">https://hexo.io/zh-cn/</a></p><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-28/49821520.jpg" alt=""></p><br><p><strong>使用 npm 安装 Hexo</strong>：在命令行中输入</p><br><pre><code>npm install hexo-cli -g<br></code></pre><br><p>然后你将会看到下图，可能你会看到一个<code>WARN</code>，但是不用担心，这不会影响你的正常使用。</p><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-28/41219383.jpg" alt=""></p><br><p>查看Hexo的版本</p><br><pre><code>hexo version<br></code></pre><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-29/81453389.jpg" alt=""></p><br><p>安装 Hexo 完成后，请执行下列命令来初始化 Hexo，用户名改成你的，Hexo 将会在指定文件夹中新建所需要的文件。</p><br><pre><code>hexo init bestGao.github.io<br><br>cd bestGao.github.io<br><br>npm install<br></code></pre><br><p>新建完成后，指定文件夹的目录如下：</p><br><pre><code>.<br>├── .deploy         #需要部署的文件<br>├── node_modules    #Hexo插件<br>├── public          #生成的静态网页文件<br>├── scaffolds       #模板<br>├── source          #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里<br>| ├── _drafts       #草稿<br>| └── _posts        #文章<br>├── themes          #主题<br>├── _config.yml     #全局配置文件<br>└── package.json    #npm 依赖等<br></code></pre><br><p><strong>运行本地 Hexo 服务</strong></p><br><pre><code>hexo server<br>或者<br>hexo s<br></code></pre><br><p>您的网站会在 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000</a> 下启动。如果 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000</a> 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。</p><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-28/34921926.jpg" alt=""></p><br><p><strong>注意1</strong>：执行hexo server提示找不到该指令</p><br><p>解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：</p><br><pre><code>sudo npm install hexo-server<br>或者<br>npm install hexo -server –save<br></code></pre><br><h2 id="hexo-github-pages"><a class="headeranchor-link" name="user-content-hexo-github-pages" href="#hexo-github-pages"></a>关联 Hexo 与 GitHub Pages</h2><br><p>我们如何让本地git项目与远程的github建立联系呢？用 SSH keys</p><br><p><strong>生成SSH keys</strong></p><br><p>输入你自己的邮箱地址</p><br><pre><code>ssh-keygen -t rsa -C “80583600@qq.com”<br></code></pre><br><p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码。</p><br><p><strong>添加 SSH Key 到 GitHub</strong></p><br><p>打开 <code>C:\Users\bxm09.ssh\id_rsa.pub</code>，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 <a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a> 的 <code>new SSH key</code> 中</p><br><p><strong>测试</strong></p><br><p>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</p><br><pre><code>ssh -T git@github.com<br></code></pre><br><p>如果是下面的反馈：</p><br><blockquote><br><p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br><br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br><br>Are you sure you want to continue connecting (yes/no)?</p>

<p></p></blockquote><p></p>
<p>不要紧张，输入yes就好，然后会看到：</p><br><pre><code>Hi aierui! You’ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre><br><p><strong>配置Git个人信息</strong></p><br><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br><br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</p><br><pre><code>git config –global user.name “bestGao”<br>git config –global user.email “80583600@qq.com”<br></code></pre><br><p><strong>配置 Deployment</strong></p><br><p>在<code>_config.yml</code>文件中，找到<code>Deployment</code>，然后按照如下修改，用户名改成你的：</p><br><p>需要注意的是：冒号后面记得空一格！</p><br><pre><code># Deployment<br>## Docs: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">https://hexo.io/docs/deployment.html</a><br>deploy:<br>  type: git<br>  repo: git@github.com:bestGao/bestGao.github.io.git<br>  branch: master<br></code></pre><br><p><strong>本地文件提交到 GitHub Pages</strong></p><br><pre><code>// 删除旧的 public 文件<br>hexo clean<br><br>// 生成新的 public 文件<br>hexo generate<br>或者<br>hexo g<br><br>// 开始部署<br>hexo deploye<br>或者<br>hexo d<br></code></pre><br><p>在浏览器中输入 <a href="https://bestGao.github.io/" target="_blank" rel="external">https://bestGao.github.io</a> （用户名改成你的）看到了 Hexo 与 GitHub Pages 已经成功关联了，哇哇哇哇哇哇，开心死你了，不要忘了回来给我点赞哟 ~</p><br><p><strong>注意1</strong>：若上面操作失败，则需要提前安装一个扩展：</p><br><pre><code>npm install hexo-deployer-git –save<br></code></pre><br><p><strong>注意2</strong>：如果在执行 <code>hexo d</code> 后,出现 <code>error deployer not found:github</code> 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。</p><br><blockquote><br><p>Permission denied (publickey).<br><br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br><br>and the repository exists.</p>

<p></p></blockquote><p></p>
<p><strong>注意3</strong>：怎么避免 .md 文件被解析？</p><br><p>Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了 README. md，它也会在你下一次部署时被删去。怎么解决呢？</p><br><p>在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。</p><br><h2 id="github-pages"><a class="headeranchor-link" name="user-content-github-pages" href="#github-pages"></a>GitHub Pages 地址解析到个人域名</h2><br><blockquote><br><p>Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。</p>

<p></p></blockquote><p></p>
<p>看着博客的域名是二级域名，总有一种寄人篱下的感觉，为了让这个小窝看起来更加正式，我在阿里云上买了一个域名，打算将博客绑定自己的域名。</p><br><p>进行该绑定过程，其实就是一个重定向的过程。</p><br><p>在 GitHub 仓库的根目录下建立一个 <code>CNAME</code> 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加<code>http://</code></p><br><pre><code>www.lovebxm.com<br></code></pre><br><p>注意：CNAME 一定是在你 Github 项目的 master 根目录下</p><br><p>进入<a href="https://dc.aliyun.com/tcparse/dns.htm" target="_blank" rel="external">阿里云域名解析地</a>址，添加解析：</p><br><ol><br><li>记录类型选择<code>CNAME</code></li><br><li>主机记录填<code>www</code></li><br><li>解析线路选择<code>默认</code></li><br><li>记录值填<code>yourname.github.io</code></li><br><li>TTL值为<code>10</code>分钟</li><br><li>再添加一个解析，记录类型<code>A</code></li><br><li>主机记录填<code>www</code></li><br><li>解析线路选择<code>默认</code></li><br><li>记录值填你GitHub 的ip地址（在cmd中ping：）</li><br></ol><br><pre><code>ping bestGao.github.com<br></code></pre><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-29/79989003.jpg" alt=""></p><br><p>点击保存，等 1 分钟，访问下你自己的域名，一切就ok了。</p><br><p>域名绑定成功，域名解析成功，因此你在浏览中输入 <a href="http://www.lovebxm.com/" target="_blank" rel="external">www.lovebxm.com</a>，或 lovebxm.com 就可以访问到博客了，输入 bestGao.github.io 会重定向到 <a href="http://www.lovebxm.com/" target="_blank" rel="external">www.lovebxm.com</a>。过程：www 的方式，会先解析成 <a href="http://xxxx.github.io/" target="_blank" rel="external">http://xxxx.github.io</a>，然后根据 CNAME 再变成 www</p><br><p><strong>注意</strong>：CNAME文件在下次 <code>hexo deploy</code>的时候就消失了，需要重新创建，这样就很繁琐</p><br><p>方法一：每次 <code>hexo d</code> 之后，就去 GitHub 仓库根目录新建 CNAME文件</p><br><p>方法二：在 <code>hexo g</code> 之后， <code>hexo d</code> 之前，把CNAME文件复制到 “\public” 目录下面，里面写入你要绑定的域名。</p><br><p>方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。</p><br><p>方法四：通过安装插件实现永久保留</p><br><pre><code>$ npm install hexo-generator-cname –save<br></code></pre><br><p>之后在_config.yml中添加一条</p><br><pre><code>plugins:<br>- hexo-generator-cname<br></code></pre><br><p>需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。</p><br><p><strong>注意1</strong>：每次生成的 CNAME 都是 yoursite.com 怎么解决？</p><br><p>修改 _config.yml</p><br><pre><code>url: <a href="http://www.lovebxm.com" target="_blank" rel="external">http://www.lovebxm.com</a><br>root: /<br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br></code></pre><br><h2 id="hexo_1"><a class="headeranchor-link" name="user-content-hexo_1" href="#hexo_1"></a>Hexo 的常用操作</h2><br><h3 id="_1"><a class="headeranchor-link" name="user-content-_1" href="#_1"></a>发表一篇文章</h3><br><pre><code>hexo new “文章标题”<br><br>D:\GitHub\Hexo\test&gt;hexo new “文章标题”<br>INFO  Created: D:\GitHub\Hexo\test\source_posts\文章标题.md<br></code></pre><br><p>在本地博客文件夹 <code>source_posts</code> 文件夹下看到我们新建的 markdown 文件。</p><br><p>当然，我们也可以手动添加Markdown文件在source-&gt;_deploy文件夹下，其效果同样可以媲美<code>hexo new</code></p><br><p>文章编辑好之后，运行生成、部署命令：</p><br><pre><code>hexo clean<br><br>hexo g<br><br>hexo d<br></code></pre><br><p>当然你也可以执行下面的命令，相当于上面两条命令的效果</p><br><pre><code>hexo clean<br><br>hexo d -g<br></code></pre><br><h3 id="_2"><a class="headeranchor-link" name="user-content-_2" href="#_2"></a>新建一个自定义页面</h3><br><pre><code>hexo new page folder<br></code></pre><br><h3 id="_3"><a class="headeranchor-link" name="user-content-_3" href="#_3"></a>文章如何添加多个标签</h3><br><p>有两种多标签格式</p><br><pre><code>tags: [a, b, c]<br>或<br>tags:<br>  - a<br>  - b<br>  - c<br></code></pre><br><h3 id="_4"><a class="headeranchor-link" name="user-content-_4" href="#_4"></a>显示部分文章内容</h3><br><p>如果在博客文章列表中，不想全文显示，可以增加 <code>&lt;!– more –&gt;</code>, 后面的内容就不会显示在列表。</p><br><pre><code>&lt;!–more–&gt;<br></code></pre><br><h3 id="_5"><a class="headeranchor-link" name="user-content-_5" href="#_5"></a>更改主题</h3><br><p>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a></p><br><p>Hexo主题非常，推荐使用 <code>Next</code> 为主题，请阅读 Next 的官方文档（ <a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a> ），5 分钟快速安装。</p><br><p>再提示一点，大家可以hexo主题修改一步就hexo s看下变化，初次接触对参数不清楚。只有hexo s后在可以在本地浏览到效果，Ctrl+C 停止服务器。</p><br><h3 id="_6"><a class="headeranchor-link" name="user-content-_6" href="#_6"></a>添加插件</h3><br><p>添加 sitemap 和 feed 插件</p><br><p>切换到你本地的 hexo 目 CIA ，在命令行窗口，输入以下命令</p><br><pre><code>npm install hexo-generator-feed -save<br>npm install hexo-generator-sitemap -save<br></code></pre><br><p>修改 <code>_config.yml</code>，增加以下内容</p><br><pre><code># Extensions<br>Plugins:<br>- hexo-generator-feed<br>- hexo-generator-sitemap<br>#Feed Atom<br>feed:<br>  type: atom<br>  path: atom.xml<br>  limit: 20<br>#sitemap<br>sitemap:<br>  path: sitemap.xml<br></code></pre><br><p>再执行以下命令，部署服务端</p><br><pre><code>hexo d -g<br></code></pre><br><p>配完之后，就可以访问 <a href="https://bestGao.github.io/atom.xml" target="_blank" rel="external">https://bestGao.github.io/atom.xml</a> 和 <a href="https://bestGao.github.io/sitemap.xml" target="_blank" rel="external">https://bestGao.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。</p><br><h3 id="404"><a class="headeranchor-link" name="user-content-404" href="#404"></a>添加 404 页面</h3><br><p>GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p><br><p><img src="http://oph264zoo.bkt.clouddn.com/17-5-29/38118493.jpg" alt=""></p><br><p>其实，404页面可以做更多有意义的事，来做个404公益项目吧。</p><br><p>推荐使用腾讯公益404 <a href="http://www.qq.com/404/" target="_blank" rel="external">http://www.qq.com/404/</a> ：</p><br><pre><code>&lt;script type=”text/javascript”<br>        src=”//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js”<br>        charset=”utf-8”<br>        homePageUrl=”<a href="http://www.lovebxm.com/" target="_blank" rel="external">http://www.lovebxm.com/</a>“<br>        homePageName=”回到我的主页”&gt;<br>&lt;/script&gt;<br></code></pre><br><p>复制上面代码，贴粘到目录下新建的404.html即可！</p><br><h3 id="pc"><a class="headeranchor-link" name="user-content-pc" href="#pc"></a>多PC同步管理博客</h3><br><p>很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。</p><br><ol><br><li>A电脑备份博客内容到github</li><br></ol><br><p>配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public</p><br><ol><br><li>初始化仓库。</li><br></ol><br><p>在博客根目录下，在git bash下依次执行git init和git remote add origin 为远程仓库地址。</p><br><ol><br><li>同步到远程仓库。</li><br></ol><br><p>gitbash下依次执行以下命令</p><br><pre><code>git add . #添加目录下所有文件<br><br>git commit -m “更新说明” #提交并添加更新说明<br><br>git push -u origin master #推送更新到远程仓库<br></code></pre><br><ol><br><li>B电脑拉下远程仓库文件</li><br></ol><br><p>在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令：</p><br><pre><code>git init<br><br>git remote add origin &lt;server&gt;<br><br>git fetch –all<br><br>git reset –hard origin/master<br></code></pre><br><ol><br><li>发布博客后同步</li><br></ol><br><p>在B电脑发布完博客之后，记得将博客备份同步到远程仓库<br><br>执行以下命令：</p><br><pre><code>git add .<br><br>#可以用git master 查看更改内容<br><br>git commit -m “更新信息”<br><br>git push -u origin master  #以后每次提交可以直接git push<br></code></pre><br><p>平时同步管理<br><br>每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。</p><br><h3 id="_7"><a class="headeranchor-link" name="user-content-_7" href="#_7"></a>中文乱码</h3><br><p>在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为<code>UTF-8</code>编码的文件即可解决问题。</p><br><h2 id="_8"><a class="headeranchor-link" name="user-content-_8" href="#_8"></a>结束语</h2><br><p>建站的系统有很多，如：<br><br>- <a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo + GitHub Pages</a><br><br>- <a href="http://jekyll.com.cn/" target="_blank" rel="external">Jekyll + GitHub Pages</a><br><br>- <a href="https://cn.wordpress.org/" target="_blank" rel="external">WordPress + 服务器 + 域名</a><br><br>- <a href="http://www.dedecms.com/" target="_blank" rel="external">DeDeCMS + 服务器 + 域名</a><br><br>- …</p><br><p>使用 Hexo + GitHub Pages 建站，有优点也有缺点：<br><br>- GitHub Pages 不支持数据库管理，所以你只能做静态页面的博客，不能像其他博客（如 WordPress）那样通过数据库管理自己的博客内容。<br><br>- 但是，GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间。<br><br>- 个人博客真的有必要用数据库吗？答案是否定的。博客静态化，评论记录使用第三方的 <a href="https://gentie.163.com/info.html" target="_blank" rel="external">网易云跟帖</a>就可以了。静态的博客更有利于搜索引擎蜘蛛爬取，轻量化的感觉真的很好。<br><br>- 通过 Hexo 你可以轻松地使用 Markdown 编写文章，非常符合我的口味。Markdown 真的是专门针对程序员开发的语言啊，现在感觉没有 Markdown什么都不想写。什么富文本编辑器，什么word，太麻烦了！而且样式都好丑！效率太低！</p><br><p>推荐几个很好用的在线 Markdown 编辑器：<br><br>- 作业部落：<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">https://www.zybuluo.com/mdeditor</a><br><br>- 马克飞象：<a href="https://maxiang.io/" target="_blank" rel="external">https://maxiang.io</a></p><br><p>推荐图床：<br><br>- <a href="https://jiantuku.com/#/" target="_blank" rel="external">极简图床 + chrome 插件 + 七牛空间</a>，七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力。</p>]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
